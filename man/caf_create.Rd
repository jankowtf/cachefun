% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/internal_cache.R
\name{caf_create}
\alias{caf_create}
\title{Create cache-aware function}
\usage{
caf_create(fun = NULL, ..., observes = list(), .refresh_default = TRUE)
}
\description{
Create cache-aware function
}
\examples{

# Introduction ------------------------------------------------------------

library(cachefun)
# Define a regular function that you'd like to make "cache-aware"
fun <- function() Sys.time()

# Turn this function into a cache-aware function
caf <- caf_create(fun = fun)

str(caf)
# Note that default value for arg '.refresh = TRUE' >> by default, the inner
# function is always executed (internal cache is always updated). This implies
# that the function behaves like any regular R function unless you explicitly
# tell it to return the internal cache in a particular call by setting '.refresh
# = FALSE'.

caf() # Inner function executed, result is cached
Sys.sleep(1)
caf() # Inner function executed, result is cached
Sys.sleep(1)
caf(.refresh = FALSE) # Inner function NOT executed, internal cache returned
Sys.sleep(1)
caf(.refresh = FALSE) # Inner function NOT executed, internal cache returned
Sys.sleep(1)
caf() # Inner function executed, result is cached
Sys.sleep(1)
caf(.refresh = FALSE) # Inner function NOT executed, internal cache returned

# Change the default value of args ----------------------------------------

library(cachefun)
fun <- function() Sys.time()
caf <- caf_create(fun = fun, .refresh_default = FALSE)

str(caf)
# Note that default value for arg '.refresh = FALSE' >> you reversed the
# pre-configured default settings. This implies that the function will always
# return the internal cache value unless you explicitly tell it not to by
# setting `.refresh = TRUE` in a particular call

caf() # Inner function is INITIALLY executed (as cache is still empty),
        # result is cached
caf() # Inner function NOT executed, internal cache returned
caf(.refresh = TRUE) # Explicit refresh request:
                      # Inner function executed, result is cached
caf() # Inner function NOT executed, internal cache returned

# Inner function with arguments ------------------------------------------

library(cachefun)
fun <- function(x) Sys.time() + x

caf <- caf_create(fun = fun)

caf(x = 3600) # Inner function executed, result is cached
caf(x = 3600 * 5, .refresh = FALSE) # Inner function NOT executed, internal cache returned
caf(x = 3600 * 5) # Inner function executed, result is cached

# Reset internal cache ----------------------------------------------------

library(cachefun)
fun <- function(x) rnorm(x)

caf <- caf_create(fun = fun)

res <- caf(x = 1000)

caf_reset(caf = caf)

# Reactive dependencies ---------------------------------------------------

library(cachefun)

# Define 'caf_1' that 'caf_2' will depend on
fun_1 <- function(x) x
caf_1 <- caf_create(fun = fun_1)

# Define 'caf_2' that depends on 'caf_1'
fun_2 <- function(x, caf_1) {
  caf_1(.refresh = FALSE) + x
}
caf_2 <- caf_create(fun = fun_2, caf_1 = caf_1)
# Note that we state the dependency by relying on the internal cache of 'caf_1'
# ('.refresh = FALSE'). Behind the scenes, 'caf_create' takes care of turning a
# dependencies that are defined as args of the inner function into an
# **reactive** ones (directly leveraging shiny's reactive capabilities). This
# means that 'caf_2' will be re-evaluated whenever the cached return value of
# dependency 'caf_1' is updated. In shiny terms, the cache of 'caf_2' is
# autmatically invalidated when it needs to be and you never run the risk of
# being "out-of-sync" with dependencies

caf_1(x = 10)
caf_2(x = 50)

caf_1(x = 100)
caf_2(x = 50, .refresh = FALSE)
# Note that even though we explicitly requested that 'caf_2' should return the
# internally cached value of the previous execution (60), the inner function was
# instead re-evaluated. This is because the cached value of 'caf_1' has changed
# which automatically invalidates all reactive components that depend on it
# (i.e. the cache value of 'caf_2'). This way you can be sure that even though
# you might like to use cached values, you still never run the risk of being
# out-of-sync regarding your function's dependencies

caf_2(x = 200)
}
